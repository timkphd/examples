;The functions remove_n, remove_n_help, and replace are used
;by the routine exchange.  Exchange takes a list and exchanges
;two elements.
(define remove_n_help (lambda (l n m)
                   (if (null? l) 
                       '()
                           (if (= n m)
                               (cdr l)
                               (cons  (car l) (remove_n_help (cdr l) n (+ 1 m)))))))

(define remove_n (lambda (l n) (remove_n_help l n 1)))

(define replace (lambda (l n c)
                  (if (null? l)
                      '()
                      (if (= 1 c) (cons n (cdr l))
                          (cons (car l) (replace (cdr l) n (- c 1)))))))
(define exchange (lambda (l n m)
                   (replace (replace l (nth n l) m) (nth m l) n)))

;Mapit is similar to Kamin's mapcar.
(define mapit (lambda (f l) (if (null? l) 
                                 '()
                                 (append (f (car l)) (mapit f (cdr l))))))

;Perm is the first function of real interest.  Given a list l and two integer
;n and m it returns the list of lists in which, for each sublist element n and m
;are exchanged.  M goes from the initial value upto the size of the list.
(define perm (lambda (l n m)
                (if (> m (length l))
                    '()
                    (cons (exchange l n m) (perm l n (+ 1 m))))))


;The permutation of a list of two elements is (perm '(a b) 1 1)
;For three elements the permutation is the permutations of the list
;(perm '(a b c) 1 1) = ((a b c) (b a c) (c b a))
;generated by exchanging elements two and three.  This new list is
;generated by the function: 

(mapit (lambda (x) (perm x 2 2)) ((lambda (x) (perm x 1 1))  '(a b c)))

;We have or recursive definition for permutations.  From this point we can
;define the arbitary permutation function as permute2 given below.  

(define mute2 (lambda (m l)
                (if (= 1 m) 
                    (perm l 1 1)
                    (mapit (lambda (x) (perm x m m)) (mute2 (- m 1) l)))))

(define permute2 (lambda (l) (mute2 (- (length l) 1) l)))



;There is another way to procede.  I wanted to test the Scheme ability to create
;a list which is actually the representation of a function and then evaluate that
;list as a function.  The following version of permute does this.  It creates a
;list which is a function then uses eval to evaluate that function.  Given a list
;of length 3 "func" becomes the a general version of the function given above.

;(mapit (lambda (x) (perm x 2 2)) ((lambda (x) (perm x 1 1))  l))

(define pose (lambda (j)
               (cons 'mapit (list (append '(lambda) '((x)) (list (append '(perm) '(x) (list j) (list j))))))))
(define mute (lambda (n l func)
               (if (= n (length l))
                   (eval func)
                   (if (= 1 n)
                       (mute (+ 1 n) l '((lambda (x) (perm x 1 1))  l))
                       (let ((z n))
                         (mute (+ 1 n) l (append 
                                           (pose n) 
                                           (list func) )))))))
(define permute (lambda (l) (mute 1 l '())))


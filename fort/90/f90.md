


#*Advanced Fortran 90*


###Timothy H. Kaiser,Ph.D. 
 Written:  Summer 1997


- - -

## [](Introduction)Introduction


- 
    Personal Introduction

- 
    The mind of the language writers

- 
    Justification for topics covered

- 
    Classification of topics covered

- 
    Listing of covered topics

- 
    Format of our talk

- 
    Meat


- - -

## [](Who_am_I?)Who am I?


- 
    Wide experience background
    
        
    - 
        Physics
        
        
    - 
        Electrical Engineering
        
        
    - 
        Computer Science
        
    

- 
    .gt. 25 years programming
    
        
    - 
        Defense Industry
        
        
    - 
        Academia
        
    
    

- 
    Languages
    
        
    - 
        Fortran
        
        
    - 
        C
        
        
    - 
        C++
        
        
    - 
        Pascal
        
        
    - 
        Lisp
        
        
    - 
        Java
        
        
    - 
        Python
        
        
    - 
        Others
        
    

- 
    Beta tester of several Fortran compilers

- 
    I have had the chance to make just about every mistake in the book and
    some that ain't


- - -
##[](The_mind_of_the_language_writers)The mind of the language writers What were they thinking?


- 
    Enable portable codes
    
        
    - 
        Same precision
        
        
    - 
        Include many common extensions
        
    

- 
    More reliable programs

- 
    Getting away from underlying hardware

- 
    Move toward parallel programming

- 
    Run old programs

- 
    Ease of programming
    
        
    - 
        Writing
        
        
    - 
        Maintaining
        
        
    - 
        Understanding
        
        
    - 
        Reading
        
    

- 
    Recover C and C++ users


 

- - -
##Why Fortran?

 *"I don't know what the technical characteristics of  
 the standard language for scientific and engineering  
 computation in the year 2000 will be... but I know it  
 will be called Fortran." John Backus*


- 
    Language of choice for Scientific programming

- 
    Large installed user base.

- 
    Fortran 90 has most of the features of C . . . and then some

- 
    Principal language on the IBM SP Supercomputer and all Cray machines

- 
    The compilers produce better programs



- - -

## [](Justification_of_topics)Justification of topics


- 
    Enhance performance

- 
    Enhance portability

- 
    Enhance reliability

- 
    Enhance maintainability


- - -


## [](Classification_of_topics)Classification of topics


- 
    New useful features

- 
    Old tricks

- 
    Power features


- - -


## [](Listing_of_topics_covered)Listing of topics covered


1. 
    Listing of topics covered

1. 
    Format for our talk

1. 
    What is a Genetic Algorithm

1. 
    Simple algorithm for a GA

1. 
    Our example problem

1. 
    Start of real Fortran
    90 discussion

1. 
    Comparing a FORTRAN 77 routine to a Fortran 90 routine

1. 
    Obsolescent features

1. 
    New source Form (and related things)

1. 
    New data declaration method

1. 
    Kind facility

1. 
    Modules

1. 
    Module functions and subroutines

1. 
    Allocatable arrays (the basics)

1. 
    Passing arrays to subroutines

1. 
    Interface for passing arrays

1. 
    Optional arguments and intent

1. 
    Derived data types

1. 
    Using defined types

1. 
    User defined operators

1. 
    Recursive functions introduction

1. 
    Fortran 90 recursive functions

1. 
    Pointers

1. 
    Function and subroutine
    overloading

1. 
    Fortran Minval and Minloc
    routines

1. 
    Pointer assignment

1. 
    More pointer
    usage, association and nullify

1. 
    Pointer usage to reference
    an array

1. 
    Data assignment with structures

1. 
    Using the user defined operator

1. 
    Passing arrays with a given
    arbitrary lower bounds

1. 
    Using pointers
    to access sections of arrays

1. 
    Allocating an array
    inside a subroutine

1. 
    Our fitness function

1. 
    Linked lists

1. 
    Linked list usage

1. 
    Our map representation

1. 
    Non advancing and character
    I/O

1. 
    Date and time functions

1. 
    Internal I/O

1. 
    Inquire function

1. 
    Namelist

1. 
    Vector valued functions

1. 
    Complete source for
    recent discussions

1. 
    Some array specific
    intrinsic functions

1. 
    The rest of our GA

1. 
    Compiler Information

1. 
    Fortan 95

1. 
    Summary

1. 
    References

[Kind facility](#kind-facility)

- - -


## [](Format_for_our_talk)Format for our talk


- 
    We will "develop" an application
    
        
    - 
        Incorporate f90 features
        
        
    - 
        Show source code
        
        
    - 
        Explain what and why as we do it
        
        
    - 
        Important parts of source code are in red    <span class="r">(If
        I don't talk about it, ask!)</span>
        
    

- 
    Application is a genetic algorithm
    
        
    - 
        Easy to understand and program
        
        
    - 
        Offers rich opportunities for enhancement
        
    



- - -


## What is a Genetic Algorithm


- 
    A "suboptimization" system
    
        
    - 
        Find good, but maybe not optimal, solutions to difficult problems
        
        
    - 
        Often used on NP-Hard or combinatorial optimization problems
        
    

- 
    Requirements
    
        
    - 
        Solution(s) to the problem represented as a string
        
        
    - 
        A fitness function
        
            
        - 
            Takes as input the solution string
            
            
        - 
            Output the desirability of the solution
            
        
        
    - 
        A method of combining solution strings to generate new solutions
        
    

- Find solutions to problems by Darwinian evolution
        
    - Potential solutions ar though of as living entities in a population
        
    - The strings are the genetic codes for the individuals
        
    - Fittest individuals are allowed to survive to reproduce
        
    



- - -


## Simple algorithm for a GA


- 
    Generate a initial population, a collection of strings

- 
    do for some time
    
        
    - 
        evaluate each individual (string) of the population using the fitness function
        
        
    - 
        sort the population with fittest coming to the top
        
        
    - 
        allow the fittest individuals to "sexually" reproduce replacing the old
        population
        
        
    - 
        allow for mutation
        
    

- 
    end do



- - -

 
##[]()Our example problem


- Instance:Given a map of the N  states or countries and a fixed number of colors

- 
    Find a coloring of the map, if it exists, such that no two states that share a boarder have the same color



- 
    Notes
    
    	
        		
        
    - 
        		In general, for a fixed number of colors and an arbitrary map the only
        		known way to find if there is a valid coloring is a brute force search
        		with the number of combinations = (NUMBER_OF_COLORS)**(NSTATES)
        		
        
        
        		
    - 
        		The strings of our population are integer vectors represent the coloring
        		
        
        
        		
    - 
        		Our fitness function returns the number of boarder violations
        		
        
        
        		
    - 
        		The GA searches for a mapping with few, hopefully 0 violations
        
        		
        
        		
    - 
        		This problem is related to several important NP_HARD problems in computer
        		science
        
        		
            
            			
            
        - Processor scheduling
            
            
            			
        - Communication and grid allocation for parallel computing
            
            
            			
        - Routing
            
            		
        
        	
        
        
        	
    
    	

	

- - -

### <span class="r"> []()Start of real Fortran 90 discussion</span>

- - -




##[]()A preview:  Comparing a FORTRAN 77 routine to a Fortran 90 routine


- 
    The routine is one of the random number generators from:  [Numerical
    Recipes, The Art of Scientific Computing. Press, Teukolsky, Vetterling
    and Flannery.  Cambridge University Press 1986.

- 
    Changes
    
        
    - 
        correct bugs
        
        
    - 
        increase functionality
        
        
    - 
        aid portability
        
    


 
 
<table>
<tbody><tr>
<td>
<pre>function ran1(idum)  
        real ran1 
        integer idum   
        real r(97)  
        parameter ( m1=259200,ia1=7141,ic1=54773)  
        parameter ( m2=134456,ia2=8121,ic2=28411)  
        parameter ( m3=243000,ia3=4561,ic3=51349)  
        integer j  
        integer iff,ix1,ix2,ix3  
        data iff /0/  
        if (idum&lt;0.or.iff.eq.0)then  
            rm1=1.0/m1  
            rm2=1.0/m2  
            iff=1  
            ix1=mod(ic1-idum,m1)  
            ix1=mod(ia1*ix1+ic1,m1)  
            ix2=mod(ix1,m2)  
            ix1=mod(ia1*ix1+ic1,m1)  
            ix3=mod(ix1,m3)  
            do 11 j=1,97  
                ix1=mod(ia1*ix1+ic1,m1)  
                ix2=mod(ia2*ix2+ic2,m2)  
                r(j)=(real(ix1)+real(ix2)*rm2)*rm1  
 11           continue  
            idum=1  
        endif  
        ix1=mod(ia1*ix1+ic1,m1)  
        ix2=mod(ia2*ix2+ic2,m2)  
        ix3=mod(ia3*ix3+ic3,m3)  
        j=1+(97*ix3)/m3  
        if(j&gt;97.or.j&lt;1)then  
            write(*,*)' error in ran1 j=',j  
            stop  
        endif  
        ran1=r(j)  
        r(j)=(real(ix1)+real(ix2)*rm2)*rm1  
        return  
     end
</pre>
</td>

<td>
<pre><span class="r">
module ran_mod   
contains
</span>   
     function ran1(idum)  
        use numz  
        implicit none  !note after use statement  
        real<span class="r">(b8)</span> ran1  
        integer<span class="r">, intent(inout), optional ::</span> idum  
        real<span class="r">(b8)</span> r(97),rm1,rm2  
        integer<span class="r">, parameter ::</span> m1=259200,ia1=7141,ic1=54773  
        integer<span class="r">, parameter ::</span> m2=134456,ia2=8121,ic2=28411  
        integer<span class="r">, parameter ::</span> m3=243000,ia3=4561,ic3=51349  
        integer j  
        integer iff,ix1,ix2,ix3  
        data iff /0/  
       <span class="r"> save ! corrects a bug in the original routine 
        if(present(idum))then</span> 
          if (idum&lt;0.or.iff.eq.0)then  
            rm1=1.0<span class="r">_b8</span>/m1  
            rm2=1.0<span class="r">_b8</span>/m2  
            iff=1  
            ix1=mod(ic1-idum,m1)  
            ix1=mod(ia1*ix1+ic1,m1)  
            ix2=mod(ix1,m2)  
            ix1=mod(ia1*ix1+ic1,m1)  
            ix3=mod(ix1,m3)  
            <span class="r">do j=1,97 </span> 
                ix1=mod(ia1*ix1+ic1,m1)  
                ix2=mod(ia2*ix2+ic2,m2)  
                r(j)=(real(ix1<span class="r">,b8</span>)+real(ix2<span class="r">,b8</span>)*rm2)*rm1  
            <span class="r">enddo</span> 
            idum=1  
          endif  
        endif  
        ix1=mod(ia1*ix1+ic1,m1)  
        ix2=mod(ia2*ix2+ic2,m2)  
        ix3=mod(ia3*ix3+ic3,m3)  
        j=1+(97*ix3)/m3  
        if(j&gt;97.or.j&lt;1)then  
            write(*,*)' error in ran1 j=',j  
            stop  
        endif  
        ran1=r(j)  
        r(j)=(real(ix1<span class="r">,b8</span>)+real(ix2,b8)*rm2)*rm1  
        return  
     end <span class="r">function ran1</span>  
 
</pre>
</td>
</tr>
</tbody></table>


- - -


##[]()Obsolescent features
 The following are available in Fortran 90. On the other hand, the concept
"obsolescence" is introduced. This means that some constructs may be removed
in the future.


- 
         Arithmetic IF-statement

- 
         Control variables in a DO-loop which are floating
    point or double-precision floating-point

- 
         Terminating several DO-loops on the same statement

- 
         Terminating the DO-loop in some other way than
    with CONTINUE or END DO

- 
         Alternate return

- 
         Jump to END IF from an outer block

- 
         PAUSE

- 
         ASSIGN and assigned GOTO and assigned FORMAT ,
    that is the whole "statement number variable" concept.

- 
         Hollerith editing in FORMAT.




- - -


##[]()New source form (and related things)




	

- Summary
        
        	
        
    - ! now indicates the start of a comment
        
        
        
        	
    - &amp; indicates the next line is a continuation
        
        
        
        	
    - Lines can be longer than 72 characters
        
        
        
        	
    - Statements can start in any column
        
        
        
        	
    - Use ; to put multiple statements on one line
        
        
        
        	
    - New forms for the do loop
        
        
        
        	
    - Many functions are generic
        
        
        
        	
    - 32 character names
        
        
        
        	
    - Many new array assignment techniques
        
    
    
    	

	

- Features
        
        	
        
    - Flexibility can aid in program readability
        
        
        
        	
    - Readability decreases errors
        
    
    	

	

- Got ya!
        
        	
        
    - Can no longer use C to start a comment
        
        
        
        	
    - Character in column 5 no longer is continue
        
        
        
        	
    - Tab is not a valid character (may produce a warning)
        
        
        
        	
    - Characters past 72 now count
        
    
    
    	

 
<pre>!23456789 
program darwin 
     real a(10), b(10), c(10), d(10), e(10), x, y 
     integer odd(5),even(5) 
     write(*,*)"starting ",<span class="r">&amp;  ! this line is continued by using "&amp;" </span>
               "darwin"    <span class="r">   ! this line in a continued from above </span>
     x=1; y=2; write(*,*)x,y <span class="r"> ! multiple statement per line -- rarely a good idea </span>
     do i=1,10   <span class="r"> ! statement lable is not required for do </span>
        e(i)=i 
     enddo 
     odd= (/ 1,3,5,7,9 /)  <span class="r">! array assignment </span>
     even=(/ 2,4,6,8,10 /) ! array assignment 
     a=1         <span class="r"> ! array assignment, every element of a = 1 </span>
     b=2 
     c=a+b+e      <span class="r">! element by element assignment </span>
     c(odd)=c(even)-1  <span class="r">! can use arrays of indices on both sides</span>
     d=sin(c)    <span class="r"> ! element by element application of intrinsics </span>
     write(*,*)d 
     write(*,*)<span class="r">abs</span>(d)  <span class="r">! many intrinsic functions are generic </span>
<span class="r"> a_do_loop :</span> do i=1,10 
               write(*,*)i,c(i),d(i) 
             enddo <span class="r">a_do_loop </span>
<span class="r">     do </span>
        if(c(10) &lt; 0.0 ) <span class="r">exit </span>
        c(10)=c(10)-1 
<span class="r">     enddo </span>
     write(*,*)c(10) 
<span class="r">     do while (c(9) &gt; 0) </span>
        c(9)=c(9)-1 
<span class="r">     enddo </span>
     write(*,*)c(9) 
end program 
</pre>
- - -

##[]()New data declaration method


- 
    Motivation
    
        
    - 
        Variables can now have attributes such as
        
            
        - 
            Parameter
            
            
        - 
            Save
            
            
        - 
            Dimension
            
        
        
    - 
        Attributes are assigned in the variable declaration statement
        
    

- 
    One variable can have several attributes

- 
    Requires Fortran 90 to have a new statement form

<pre>    integer<span class="r">,parameter :: </span>in2 = 14 
    real, parameter :: pi = 3.141592653589793239 
    real<span class="r">, save, dimension(10) :: </span>cpu_times,wall_times 
!****    the old way of doing the same    ****! 
!****    real cpu_times(10),wall_times(10) ****! 
!****    save cpu_times, wall_times        ****! 
</pre>

  
 

- 
    Other Attributes
    
        
    - 
        allocatable
        
        
    - 
        public
        
        
    - 
        private
        
        
    - 
        target
        
        
    - 
        pointer
        
        
    - 
        intent
        
        
    - 
        optional
        
    


 
  
 

- - -


## Kind facility

- 
    Motivation
    
        
    - 
        Assume we have a program that we want to run on two different machines
        
        
    - 
        We want the same representation of reals on both machines (same number
        of significant digits)
        
        
    - 
        Problem: different machines have different representations for reals
        
    



### Digits of precision for machine and data type
<table>
<tbody><tr>
<td>Machine/Data Type</td>

<td>    Real</td>

<td>      Double Precision</td>
</tr>

<tr>
<td>IBM (SP)</td>

<td>      6</td>

<td>          15</td>
</tr>

<tr>
<td>Cray (T90)</td>

<td>    15</td>

<td>          33</td>
</tr>

<tr>
<td>Cray (T3E)</td>

<td>    15 </td>

<td>          15</td>
</tr>
</tbody></table>

### <span class="r">********* or *********</span>


- 
    We may want to run with at least 6 digits today and at least 14 digits
    tomorrow

- 
    Use the Select_Real_Kind(P) function to create a data type with P digits
    of precision

 

<pre><span class="b">  sp001 % cat darwin.f </span>
program darwin 
<span class="r">! e has at least 4 significant digits </span>
  real(selected_real_kind(4))e 
<span class="r">! b8 will be used to define reals with 14 digits </span>
  integer, parameter:: b8 = selected_real_kind(14) 
  real(b8), parameter :: pi = 3.141592653589793239<span class="r">_b8 ! note usage of _b8 </span>
                                                   <span class="r">   ! with  a constant </span>
                                                   <span class="r">   ! to force precision </span>
 e= 2.71828182845904523536 
  write(*,*)"starting ",&amp;  <span class="r">! this line is continued by using "&amp;" </span>
            "darwin"       <span class="r">! this line in a continuation from above </span>
  write(*,*)"pi has ",precision(pi)," digits precision ",pi 
  write(*,*)"e has   ",precision(e)," digits precision ",e 
end program  
<span class="b">  sp001  % darwin 
 starting darwin 
 pi has  15  digits precision  3.14159265358979312 
 e has    6  digits precision  2.718281746 
sp001 % 
</span>
</pre>


- 
    Can convert to/from given precision for all variables created using "b8"
    by changing definition of "b8"

- 
    Use the Select_Real_Kind(P,R) function to create a data type with P digits
    of precision and exponent range of R


- - -


## Modules


- 
    Motivation:
    
        
    - 
        Common block usage is prone to error
        
        
    - 
        Provide most of capability of common blocks but safer
        
        
    - 
        Provide capabilities beyond common blocks
        
    

- 
    Modules can contain:
    
        
    - 
        Data definitions
        
        
    - 
        Data to be shared much like using a labeled common
        
        
    - 
        Functions and subroutines
        
        
    - 
        Interfaces (more on this later)
        
    

- 
    You "include" a module with a "use" statement


 

<pre><span class="r">module numz</span> 
<span class="r">  integer,parameter:: b8 = selected_real_kind(14)</span> 
<span class="r">  real(b8),parameter :: pi = 3.141592653589793239_b8</span> 
<span class="r">  integergene_size</span> 
<span class="r">end module</span> 

 program darwin   
    <span class="r">use numz</span>  
    <span class="r">implicit none    ! now part of the standard, put it after the use statements</span> 
   write(*,*)"pi has ",precision(pi),"
digits precision ",pi   
   call set_size()   
   write(*,*)"gene_size=",gene_size   
 end program   

subroutine set_size  
  <span class="r">use numz  </span>
  gene_size=10  
end subroutine
 

 <span class="b"> pi has  15  digits precision  3.14159265358979312  
  gene_size=10 </span>
</pre>

  

- - -

##[]()Module functions and subroutines


- 
    Motivation:
    
        
    - 
        Encapsulate related functions and subroutines
        
        
    - 
        Can "USE" these functions in a program or subroutine
        
        
    - 
        Can be provided as a library
        
        
    - 
        Only routines that contain the use statement can see the routines
        
    
    

- Example is a random number package:


<pre>module ran_mod 
! module contains three functions 
! ran1 returns a uniform random number between 0-1 
! spread returns random number between min - max 
! normal returns a normal distribution 
<span class="r">contains</span>
    <span class="r">function ran1()</span>  !returns random number between 0 - 1 
        <span class="r">use numz</span> 
        implicit none 
        real(b8) ran1,x 
        call random_number(x) ! built in fortran 90 random number function 
        ran1=x 
    end function ran1     
    <span class="r">function spread(min,max)</span>  !returns random number between min - max 
        <span class="r">use numz</span> 
        implicit none 
        real(b8) spread 
        real(b8) min,max 
        spread=(max - min) * ran1() + min 
    end function spread     
    <span class="r">function normal(mean,sigma)</span> !returns a normal distribution 
        <span class="r">use numz</span> 
        implicit none 
        real(b8) normal,tmp 
        real(b8) mean,sigma 
        integer flag 
        real(b8) fac,gsave,rsq,r1,r2 
        save flag,gsave 
        data flag /0/ 
        if (flag.eq.0) then 
        rsq=2.0_b8 
            do <span class="r">while</span>(rsq.ge.1.0_b8.or.rsq.eq.0.0_b8) ! new from for do 
                r1=2.0_b8*ran1()-1.0_b8 
                r2=2.0_b8*ran1()-1.0_b8 
                rsq=r1*r1+r2*r2 
            enddo 
            fac=sqrt(-2.0_b8*log(rsq)/rsq) 
            gsave=r1*fac 
            tmp=r2*fac 
            flag=1 
        else 
            tmp=gsave 
            flag=0 
        endif 
        normal=tmp*sigma+mean 
        return 
    end function normal end module ran_mod 
</pre>

  
 
  

- - -

 Exersize 1:  Write a program that returns 10 uniform random
numbers.
  

- - -

##[]()Allocatable arrays (the basics)


- 
    Motivation:
    
        
    - 
        At compile time we may not know the size an array need to be
        
    
    
    - 
        
    - 
        We may want to change problem size without recompiling
        
    

- 
    Allocatable arrays allow us to set the size at run time

- 
    We set the size of the array using the allocate statement

- 
    We may want to change the lower bound for an array
- 
    A simple example:



<pre>module numz 
  integer, parameter:: b8 = selected_real_kind(14) 
  integer gene_size,num_genes 
  <span class="r">integer,allocatable :: a_gene(:),many_genes(:,:) </span>
end module 
program darwin 
    use numz 
    implicit none 
    integer ierr 
    call set_size() 
    <span class="r">allocate(a_gene(gene_size),stat=ierr)</span> !stat= allows for an error code return 
    if(ierr /= 0)write(*,*)"allocation error"  ! /= is .ne. 
    <span class="r">allocate(many_genes(gene_size,num_genes),stat=ierr)</span>  !2d array 
    if(ierr /= 0)write(*,*)"allocation error" 
    write(*,*)<span class="r">lbound</span>(a_gene),<span class="r">ubound</span>(a_gene) <span class="r">! get lower and upper bound 
                                            ! for the array </span>
    write(*,*)<span class="r">size</span>(many_genes),size(many_genes,1) <span class="r">!get total size and size </span>
                                                  <span class="r">!along 1st dimension </span>
    <span class="r">deallocate</span>(many_genes) <span class="r">! free the space for the array and matrix </span>
    deallocate(a_gene) 
    allocate(a_gene(0:gene_size)) ! now allocate starting at 0 instead of 1 
    write(*,*)<span class="r">allocated</span>(many_genes),allocated(a_gene) <span class="r">! shows if allocated </span>
    write(*,*)lbound(a_gene),ubound(a_gene) 
end program 
  subroutine set_size 
    use numz 
    write(*,*)'enter gene size:' 
    read(*,*)gene_size 
    write(*,*)'enter number of genes:' 
    read(*,*)num_genes 
end subroutine set_size 

<span class="b">
    enter gene size: 
10 
 enter number of genes: 
20 
           1          10 
         200          10 
 F T 
           0          10 
</span>
</pre>

  

##[]()Passing arrays to subroutines


	

- There are several ways to specify arrays for subroutines
    
    
    <dl>
    * Explicit shape
    	*     integer, dimension(8,8)::an_explicit_shape_array
    
    
    
    * Assumed size
    	*     integer, dimension(i,*)::an_assumed_size_array
    
    
    
    * Assumed Shape
    	*     integer, dimension(:,:)::an_assumed_shape_array
    </dl>
    



- Example

<pre>subroutine arrays(an_explicit_shape_array,&amp; 
                  i                      ,&amp; !note we pass all bounds except the last 
                  an_assumed_size_array  ,&amp; 
                  an_assumed_shape_array) 
<span class="r">! Explicit shape</span> 
    integer, <span class="r">dimension(8,8)</span>::an_explicit_shape_array 
<span class="r">! Assumed size </span>
    integer, <span class="r">dimension(i,*)</span>::an_assumed_size_array 
<span class="r">! Assumed Shape </span>
    integer, <span class="r">dimension(:,:)</span>::an_assumed_shape_array 
    write(*,*)sum(an_explicit_shape_array) 
    write(*,*)lbound(an_assumed_size_array) ! why does sum not work here? 
    write(*,*)sum(an_assumed_shape_array) 
end subroutine 
</pre>

- - -

##[]()Interface for passing arrays


- 
    <span class="g">!!!!Warning!!!!  When passing assumed shape arrays as arguments you must provide an interface</span>

- 
    Similar to C prototypes but much more versatile

- 
    The interface is a copy of the invocation line and the argument definitions

- 
    Modules are a good place for interfaces

- 
    If a procedure is part of a "contains" section in a module an interface
    is not required

- 
    <span class="g">!!!!Warning!!!! The compiler may not tell you that you need an interface</span>

<pre>  module numz 
    integer, parameter:: b8 = selected_real_kind(14) 
    integer,allocatable :: a_gene(:),many_genes(:,:) 
end module module face 
    interface fitness 
        <span class="r">function fitness(vector) </span> 
        use numz 
        implicit none 
        real(b8) fitness 
        <span class="r">integer, dimension(:) ::  vector </span> 
        end function fitness 
    end interface 
end module program darwin 
    use numz 
    <span class="r">use face </span> 
    implicit none 
    integer i 
    integer vect(10) ! just a regular array 
    allocate(a_gene(10));allocate(many_genes(3,10)) 
    a_gene=1  !sets every element of a_gene to 1 
    write(*,*)fitness(a_gene) 
    vect=8 
    write(*,*)fitness(vect) ! also works with regular arrays 
    many_genes=3  !sets every element to 3 
    many_genes(1,:)=a_gene  !sets column 1 to a_gene 
    many_genes(2,:)=2*many_genes(1,:) 
    do i=1,3 
        write(*,*)fitness(many_genes(i,:)) 
    enddo 
    write(*,*)fitness(many_genes(:,1))  !go along other dimension 
!!!!write(*,*)fitness(many_genes)!!!!does not work 
end program 
<span class="r">function fitness(vector)</span> 
    use numz 
    implicit none 
    real(b8) fitness 
    <span class="r">integer, dimension(:)::  vector ! must match interface</span> 
    fitness=sum(vector) 
end function 
</pre>
  

- - -

Exersize 2:  Run this program using the "does not work line". 
Why?  Using intrinsic functions make it work?
  
Exersize 3:  Prove that f90 does not "pass by address".
  

- - -

##[]()Optional arguments and intent


- 
    Motivation:
    
        
    - 
        We may have a function or subroutine that we may not want to always pass
        all arguments
        
        
    - 
        Initialization
        
    
    

- 
    Two examples
    
        
    - Seeding the intrinsic random number generator requires keyword arguments
        
        
    - 
        To define an optional argument in our own function we use the optional
        attribute
        
    


<pre><span class="r">integer :: my_seed</span>
</pre>
### becomes
<pre><span class="r">integer, optional :: my_seed</span>
</pre>
<pre>! ran1 returns a uniform random number between 0-1 
! the seed is optional and used to reset the generator 
contains 
   function ran1(my_seed) 
      use numz 
      implicit none 
      real(b8) ran1,r 
      integer, <span class="r">optional ,intent(in)</span> :: my_seed  <span class="r">! optional argument not changed in the routine </span>
      integer,allocatable :: seed(:) 
      integer the_size,j 
      if(<span class="r">present(my_seed))</span>then            <span class="r">! use the seed if present </span>
          call <span class="r">random_seed(size=the_size)</span> <span class="r">! how big is the intrisic seed? </span>
          allocate(seed(the_size))        ! allocate space for seed 
          do j=1,the_size                 ! create the seed 
             seed(j)=<span class="r">abs</span>(my_seed)+(j-1)   <span class="r">! abs is generic </span>
          enddo 
          call <span class="r">random_seed(put=seed)      ! assign the seed </span>
          deallocate(seed)                ! deallocate space 
      endif 
      call random_number(r) 
      ran1=r 
  end function ran1 
end module program darwin 
    use numz 
    use ran_mod          <span class="r">! interface required if we have 
                         ! optional or intent arguments </span>
    real(b8) x,y 
    x=ran1<span class="r">(my_seed=12345) ! we can specify the name of the argument </span>
    y=ran1() 
    write(*,*)x,y 
    x=ran1<span class="r">(12345)         ! with only one optional argument we don't need to </span>
    y=ran1() 
    write(*,*)x,y 
end program 
</pre>

  
 

- 
    Intent is a hint to the compiler to enable optimization
    
    
    
    <dl>
    * intent(in)
    	* We will not change this value in our subroutine
    
    
    
    * intent(out)
    	* We will define this value in our routine
    
    
    
    * intent(inout)
    	* The normal situation
    </dl>
    
    



- - -

##[]()Derived data types


- 
    Motivation:
    
        
    - 
        Derived data types can be used to group different types of data together
        (integers, reals, character, complex)
        
        
    - 
        Can not be done in F77 although people have "faked" it
        
    

- 
    Example
    
        
    - 
        In our GA we define a collection of genes as a 2d array
        
        
    - 
        We call the fitness function for every member of the collection
        
        
    - 
        We want to sort the collection of genes based on result of fitness function
        
        
    - 
        Define a data type that holds the fitness value and an index into the 2d
        array
        
        
    - 
        Create an array of this data type, 1 for each member of the collection
        
        
    - 
        Call fitness function with the result being placed into the new data type
        along with a pointer into the array
        
    


- 
    Again modules are a good place for data type definitions


<pre>module galapagos 
    use numz 
    type <span class="r">thefit !the name of the type 
      sequence  ! sequence forces the data elements 
                ! to be next to each other in memory 
                ! where might this be useful? </span>
      real(b8) val   ! our result from the fitness function 
      integer index  ! the index into our collection of genes 
    end type thefit 
end module
</pre>
- - -


##[]()Using defined types

- 
    Use the % to reference various components of the derived data type


<pre>program darwin 
    use numz 
    use galapagos <span class="r">! the module that contains the type definition</span> 
    use face      <span class="r">! contains various interfaces </span> 
 implicit none 
<span class="r">! define an allocatable array of the data type 
! than contains an index and a real value </span> 
    type <span class="r">(thefit),allocatable ,target </span> :: results(:) 
! create a single instance of the data type 
    type (thefit) best 
    integer,allocatable :: genes(:,:) ! our genes for the genetic algorithm 
    integer j 
    integer num_genes,gene_size 
    num_genes=10 
    gene_size=10 
    allocate(results(num_genes))         <span class="r">! allocate the data type </span> 
                                         <span class="r">! to hold fitness and index </span> 
    allocate(genes(num_genes,gene_size)) <span class="r">! allocate our collection of genes </span> 
    call init_genes(genes)               ! starting data 
    write(*,<span class="r">'("input")'</span> ) ! we can put format in write statement 
    do j=1,num_genes 
       <span class="r">results(j)%index</span> =j 
       <span class="r">results(j)%val</span> =fitness(genes(j,:)) ! just a dummy routine for now 
       write(*,"(f10.8,i4)")<span class="r">results(j)%val,results(j)%index </span> 
    enddo 
end program 

</pre>


  

- - -


## User defined operators


- 
    Motivation
        
    - 
        With derived data types we may want (need) to define operations
        
        
    - 
        (Assignment is predefined)
        
    

- 
    Example:
    
        
    - 
        &lt;, &gt;, ==  not defined for our data types
        
            
        - 
            We want to find the minimum of our fitness values so we need &lt; operator
            
            
        - 
            In our sort routine we want to do &lt;, &gt;, ==
            
            
        - 
            In C++ terms the operators are overloaded
            
        
        
    - 
        We are free to define new operators
        
    

- 
    Two step process to define operators
    
        
    - 
        Define a special interface
        
        
    - 
        Define the function that performs the operation
        
    


<pre>module sort_mod 
!defining the interfaces 
  interface operator <span class="r">(.lt.) </span> ! overloads standard .lt. 
    module procedure <span class="r">theless</span> ! the function that does it 
  end interface   interface operator (.gt.)   ! overloads standard .gt. 
    module procedure thegreat ! the function that does it 
  end interface   interface operator (.ge.)  ! overloads standard .ge. 
    module procedure thetest ! the function that does it 
  end interface   interface operator (.converged.)  <span class="r">! new operator </span>
    module procedure index_test     ! the function that does it 
  end interface 
  <span class="r">contains      ! our module will contain 
              ! the required functions </span>
    function <span class="r">theless</span>(a,b) ! overloads &lt; for the type (thefit) 
    use galapagos 
    implicit none 
    type(thefit), <span class="r">intent (in)</span> :: a,b 
    <span class="r">logical theless           ! what we return 
    if(a%val &lt; b%val)then     ! this is where we do the test </span>
        theless=.true. 
    else 
        theless=.false. 
    endif 
    return 
  end function theless   function thegreat(a,b) ! overloads &gt; for the type (thefit) 
    use galapagos 
    implicit none 
    type(thefit), intent (in) :: a,b 
    logical thegreat 
    if(a%val &gt; b%val)then 
        thegreat=.true. 
    else 
        thegreat=.false. 
    endif 
    return 
  end function thegreat 
  function thetest(a,b)   ! overloads &gt;= for the type (thefit) 
    use galapagos 
    implicit none 
    type(thefit), <span class="r">intent (in) :: a,b </span>
    logical thetest 
    if(a%val &gt;= b%val)then 
        thetest=.true. 
    else 
        thetest=.false. 
    endif 
    return 
end function thetest 
  function index_test(a,b) <span class="r">! defines a new operation for the type (thefit) </span>
    use galapagos 
    implicit none 
    type(thefit), intent (in) :: a,b 
    logical index_test 
    if(a%index &gt; b%index)then   <span class="r">! check the index value for a difference </span>
        index_test=.true. 
    else 
        index_test=.false. 
    endif 
    return 
end function index_test 
</pre>
- - -


##[]()Recursive functions introduction


- 
    Notes
    
    
        
    - 
        Recursive function is one that calls itself
        
        
    - 
        Anything that can be done with a do loop can be done using a recursive
        function
        
    

- 
    Motivation
    
        
    - 
        Sometimes it is easier to think recursively
        
        
    - 
        Divide an conquer algorithms are recursive by nature
        
            
        - 
            Fast FFTs
            
            
        - 
            Searching
            
            
        - 
            Sorting
            
        
        
        
    


### Algorithm of searching for minimum of an array
    
<pre>    function findmin(array) 
        is size of array 1? 
           min in the array is first element 
        else 
           find minimum in left half of array using findmin function 
           find minimum in right half of array using findmin function 
           global minimum is min of left and right half 
    end function 
    </pre>
- - -

##[]()Fortran 90 recursive functions


- 
    Recursive functions should have an interface

- 
    The result and recursive keywords are required as part of the function definition

- 
    Example is a function finds the minimum value for an array




<pre><span class="r">recursive</span> function realmin(ain) <span class="r">result (themin)</span> 
<span class="r">! recursive and result are required for recursive functions</span> 
    use numz 
    implicit none 
    real(b8) themin,t1,t2 
    integer n,right 
    real(b8) ,dimension(:) :: ain 
    n=size(ain) 
    if(n == 1)then 
       themin=ain(1) <span class="r">! if the size is 1 return value</span> 
    return 
    else 
      right=n/2 
      t1=realmin(ain(1:right))   <span class="r">! find min in left half </span>
      t2=realmin(ain(right+1:n)) <span class="r">! find min in right half </span>
      themin=min(t1,t2)          ! find min of the two sides 
     endif 
end function 
 </pre>



- 
    Example 2 is the same except the input data is our derived data type


<pre><span class="r">!this routine works with the data structure thefit not reals </span>
<span class="r">recursive</span> function typemin(ain) <span class="r">result (themin) </span>
    use numz 
 use sort_mod 
 use galapagos 
 implicit none 
 real(b8) themin,t1,t2 
 integer n,right 
    type <span class="r">(thefit)</span> ,dimension(:) :: ain <span class="r">! this line is different </span>
 n=size(ain) 
 if(n == 1)then 
     themin=ain(1)%val  <span class="r">! this line is different </span>
  return 
 else 
  right=n/2 
  t1=typemin(ain(1:right)) 
  t2=typemin(ain(right+1:n)) 
  themin=min(t1,t2) 
 endif 
end function 
</pre>
- - -

##[]()Pointers
 

- 
    Motivation
        
    - 
        Can increase performance
        
        
    - 
        Can improve readability
        
        
    - 
        Required for some derived data types (linked lists and trees)
        
        
    - 
        Useful for allocating "arrays" within subroutines
        
        
    - 
        Useful for referencing sections of arrays
        
    

- 
    Notes
    
        
    - 
        Pointers can be thought of as an alias to another variable
        
        
    - 
        In some cases can be used in place of an array
        
        
    - 
        To assign a pointer use =&gt; instead of just =
        
        
    - 
        Unlike C and C++, pointer arithmetic is not allowed
        
    


 

- 
    First pointer example
    
        
    - 
        Similar to the last findmin routine
        
        
    - 
        Return a pointer to the minimum
        
    


<pre>recursive function pntmin(ain) <span class="r">result (themin)</span> ! return a pointer 
 use numz 
 use galapagos 
 use sort_mod ! contains the &lt; operator for thefit type 
 implicit none 
 <span class="r">type (thefit),pointer:: themin,t1,t2 </span>
 integer n,right 
    type (thefit) ,dimension(:),target :: ain 
 n=size(ain) 
 if(n == 1)then 
     themin=&gt;ain(1) !this is how we do pointer assignment 
  return 
 else 
  right=n/2 
  t1=&gt;pntmin(ain(1:right)) 
  t2=&gt;pntmin(ain(right+1:n)) 
  if(t1 &lt; t2)then; themin=&gt;t1; else; themin=&gt;t2; endif 
 endif 
end function 
</pre>
  

- - -

Exercise 4:  Carefully write a recursive N! program. 
- - -

##[]()Function and subroutine overloading


- 
    Motivation
    
        
    - 
        Allows us to call functions or subroutine with the same name with different
        argument types
        
        
    - 
        Increases readability
        
    

- 
    Notes:
    
        
    - 
        Similar in concept to operator overloading
        
        
    - 
        Requires an interface
        
        
    - 
        Syntax for subroutines is same as for functions
        
        
    - 
        Many intrinsic functions have this capability
        
            
        - 
            abs (reals,complex,integer)
            
            
        - 
            sin,cos,tan,exp(reals, complex)
            
            
        - 
            array functions(reals, complex,integer)
            
        
        
        
    - 
        Example
        
            
        - 
            Recall we had two functions that did the same thing but with different argument types
            
        
        
    
    
- <pre>        recursive function realmin(ain) result (themin) 
            real(b8) ,dimension(:) :: ain         recursive function typemin(ain) result (themin) 
            type (thefit) ,dimension(:) :: ain 
    </pre>
    

- 
    We can define a generic interface for these two functions and call
    them using the same name

<pre>! note we have two functions within the same interface 
! this is how we indicate function overloading 
! <span class="r">both functions are called "findmin" in the main program </span>
interface <span class="r">findmin</span>  
! the first is called with an array of reals as input 
        recursive function <span class="r">realmin(ain)</span> result (themin) 
          use numz 
       real(b8) themin 
          <span class="r">real(b8) ,dimension(:) :: ain </span>
        end function ! the second is called with a array of data structures as input 
     recursive function <span class="r">typemin</span>(ain) result (themin) 
          use numz 
    use galapagos 
       real(b8) themin 
          <span class="r">type (thefit) ,dimension(:) :: ain </span>
     end function 
    end interface 
</pre>


- 
    Example usage

<pre>program darwin 
    use numz 
    use ran_mod 
    use galapagos ! the module that contains the type definition 
    use face      ! contains various interfaces 
    use sort_mod  ! more about this later it 
                  ! contains our sorting routine 
      ! and a few other tricks 
    implicit none 
<span class="r">
! create an allocatable array of the data type 
! than contains an index and a real value 
    type (thefit),allocatable ,target :: results(:) 
! create a single instance of the data type 
    type (thefit) best 
! pointers to our type 
    type (thefit) ,pointer :: worst,tmp </span>
    integer,allocatable :: genes(:,:) ! our genes for the ga 
    integer j 
    integer num_genes,gene_size 
    real(b8) x 
    real(b8),allocatable :: z(:) 
    real(b8),pointer :: xyz(:) ! we'll talk about this next 
    num_genes=10 
    gene_size=10 
    allocate(results(num_genes))         ! allocate the data type to 
    allocate(genes(num_genes,gene_size)) ! hold our collection of genes 
    call init_genes(genes)               ! starting data 
    write(*,'("input")') 
    do j=1,num_genes 
       results(j)%index=j 
       results(j)%val=fitness(genes(j,:)) ! just a dummy routine 
       write(*,"(f10.8,i4)")results(j)%val,results(j)%index 
    enddo     allocate(z(size(results))) 
    z=results(:)%val <span class="r">! copy our results to a real array ! use a recursive subroutine operating on the real array </span>
    write(*,*)"the lowest fitness: ",<span class="r">findmin(z) </span>
<span class="r">! use a recursive subroutine operating on the data structure </span>
    write(*,*)"the lowest fitness: ",<span class="r">findmin(results) </span>
end program
</pre>
    
  

- - -

##[]()Fortran Minval and Minloc routines


- 
    Fortran has routines for finding minimum and maximum values in arrays and
    the locations
    
        
    - 
        minval
        
        
    - 
        maxval
        
        
    - 
        minloc (returns an array)
        
        
    - 
        maxloc (returns an array)
        
    



<pre><span class="r">! we show two other methods of getting the minimum fitness </span> 
! use the <span class="r">built in f90 routines </span> on a real array 
    write(*,*)"the lowest fitness: ",<span class="r">minval(z),minloc(z) </span>
</pre>

  
 
- - -

## Pointer assignment


- 
    This is how we use the pointer function defined above

- 
    worst is a pointer to our data type

- 
    note the use of =&gt;

<pre>! use a recursive subroutine operating on the data 
! structure and returning a pointer to the result 
    <span class="c">worst=&gt;</span>pntmin(results) <span class="c">! note pointer assignment </span>
! what will this line write? 
 write(*,*)"the lowest fitness: ",worst
 </pre>

- - -

##[]()More pointer usage, association and nullify


- 
    Motivation
        
    - 
        Need to find if pointers point to anything
        
        
    - 
        Need to find if two pointers point to the same thing
        
        
    - 
        Need to deallocate and nullify when they are no longer used
        
    

- 
    Usage
    
        
    - 
        We can use associated() to tell if a pointer has been set
        
        
    - 
        We can use associated() to compare pointers
        
        
    - 
        We use nullify to zero a pointer
        
    


 

<pre>! This code will print "true" when we find a match, 
! that is the pointers point to the same object 
    do j=1,num_genes 
     tmp=&gt;results(j) 
        write(*,"(f10.8,i4,l3)")results(j)%val,   &amp; 
                                results(j)%index, &amp;
           <span class="c">associated</span>(tmp,worst) 
    enddo 
    <span class="c">nullify</span>(tmp) 
</pre>
  


- 
    Notes:
    
        
    - 
        <span class="r">If a pointer is nullified the object to which it points is not deallocated.</span>
        
        
    - 
        <span class="r">In general, pointers as well as allocatable arrays become undefined on leaving a subroutine</span>
        
        
    - 
        <span class="r">This can cause a memory leak</span>
        
    


- - -

##[]()Pointer usage to reference an array without copying

- 
    Motivation
        
    - 
        Our sort routine calls a recursive sorting routine
        
        
    - 
        It is messy and inefficient to pass the array to the recursive routine
        
    

- 
    Solution
    
        
    - 
        We define a "global" pointer in a module
        
        
    - 
        We point the pointer to our input array
        
    


<pre>module Merge_mod_types 
    use galapagos 
    type(thefit),allocatable :: work(:) ! a "global" work array 
    <span class="c">type(thefit), pointer:: a_pntr(:)   ! this will be the pointer to our input array </span>
end module Merge_mod_types 
  subroutine Sort(ain, n) 
    use Merge_mod_types 
    implicit none 
    integer n 
    type(thefit), target:: ain(n) 
    allocate(work(n)) 
    nullify(a_pntr) 
    <span class="c">a_pntr=&gt;ain  ! we assign the pointer to our array 
                 ! in RecMergeSort we reference it just like an array </span>
    call RecMergeSort(1,n) ! very similar to the findmin functions 
    deallocate(work) 
    return 
end subroutine Sort 
</pre>


- 
    In our main program sort is called like this:


<pre>! our sort routine is also recursive but 
! also shows a new usage for pointers 
    call sort(results,num_genes) 
    do j=1,num_genes 
       write(*,"(f10.8,i4)")results(j)%val,   &amp; 
                            results(j)%index 
    enddo 
</pre>
- - -

##[]()Data assignment with structures
<pre>! we can copy a whole structure 
! with a single assignment 
    best=results(1) 
    write(*,*)"best result ",best 
    </pre>
  

- - -

##[]()Using the user defined operator

<pre>! using the user defined operator to see if best is worst 
! recall that the operator .converged. checks to see if %index matches 
    worst=&gt;pntmin(results) 
    write(*,*)"worst result ",worst 
    write(*,*)"converged=",(best .converged. worst)
    </pre>

- - -

##[]()Passing arrays with a given arbitrary lower bounds


- Motivation
    
        
    - Default lower bound within a subroutine is 1
        
        
    - May want to use a different lower bound
        
    


<pre>    <span class="r">if(allocated(z))deallocate(z) </span>
    allocate(z(-10:10)) ! a 21 element array 
    do j=-10,10 
       z(j)=j 
    enddo <span class="r">! pass z and its lower bound </span>
! in this routine we give the array a specific lower 
! bound and show how to use a pointer to reference 
! different parts of an array using different indices 
  call boink1(z,<span class="r">lbound(z,1)) ! why not just lbound(z) instead of lbound(z,1)? 
                             ! lbound(z) returns a rank 1 array </span>
     subroutine boink1(a,n) 
     use numz 
     implicit none 
     integer,<span class="r"></span>intent(in) ::<span class="c"> n </span>
     real(b8),<span class="r">dimension(n:)</span>:: a ! this is how we set lower bounds in a subroutine 
     write(*,*)lbound(a),ubound(a) 
   end subroutine
</pre>

  
 
### <span class="g">Warning:  because we are using an assumed shape array we need an interface</span>
##[]()Using pointers to access sections of arrays


- Motivation
    
        
    - Can increase efficiency
        
        
    - Can increase readability
        
    


<pre>call boink2(z,lbound(z,1)) 
 
subroutine boink2(a,n) 
use numz 
implicit none 
integer,intent(in) :: n 
real(b8),dimension(n:),target:: a 
real(b8),dimension(:),pointer::b 
<span class="r">b=&gt;a(n:) ! b(1) "points" to a(-10) </span>
write(*,*)"a(-10) =",a(-10),"b(1) =",b(1) 
<span class="r">b=&gt;a(0:) ! b(1) "points" to a(0) </span>
write(*,*)"a(-6) =",a(-6),"b(-5) =",b(-5) 
end subroutine
</pre>

- - -

##[]()Allocating an array inside a subroutine and passing it back


- Motivation
        
    - Size of arrays are calculated in the subroutine
        
    



<pre>module numz 
    integer, parameter:: b8 = selected_real_kind(14)
end module

program bla
   use numz
   real(b8), dimension(:) ,pointer :: xyz 

   <span class="r">interface boink 
     subroutine boink(a) 
     use numz
     implicit none 
     real(b8), dimension(:), pointer :: a 
     end subroutine 
   end interface </span>

   nullify(xyz) ! nullify sets a pointer to null 
   write(*,'(l5)')associated(xyz) ! is a pointer null, should be 
   call boink(xyz) 
   write(*,'(l5)',advance="no")associated(xyz) 
   if(associated(xyz))write(*,'(i5)')size(xyz) 
end program  

subroutine boink(a) 
    use numz 
    implicit none 
    real(b8),dimension(:),pointer:: a 
    if(associated(a))deallocate(a) 
    allocate(a(10)) 
end subroutine 



<span class="b">     F
     T
10</span>
</pre>
  

- - -

##[]()Our fitness function
Given a fixed number of colors, M, and a description of a map of a collection
of  N states.
  
Find a coloring of the map such that no two states that share a boarder
have the same coloring.

### Example input is a sorted list of 22 western states
<pre>22
ar ok tx la mo xx
az ca nm ut nv xx
ca az nv or xx
co nm ut wy ne ks xx
ia mo ne sd mn xx
id wa or nv ut wy mt xx
ks ne co ok mo xx
la tx ar xx
mn ia sd nd xx
mo ar ok ks ne ia xx
mt wy id nd xx
nd mt sd wy xx
ne sd wy co ks mo ia xx
nm az co ok tx mn xx
nv ca or id ut az xx
ok ks nm tx ar mo xx
or ca wa id xx
sd nd wy ne ia mn xx
tx ok nm la ar xx
ut nv az co wy id xx
wa id or mt xx
wy co mt id ut nd sd ne xx
</pre>
Our fitness function takes a potential coloring, that is, an integer
vector of length N and a returns the number of boarders that have states
of the same coloring

 


- 
    How do we represent the map in memory?
    
        
    - 
        One way would be to use an array but it would be very sparse
        
        
    - 
        Linked lists are often a better way
        
    


- - -

##[]()Linked lists


	

- Motivation
    		
        		
        
    - We have a collection of states and for each state a list of adjoining states. (Do not count a boarder twice.)
        
        		
    - Problem is that you do not know the length of the list until runtime.
        
        		
    - List of adjoining states will be different lengths for different states
        
        		
    
    	

	

- Solution
    		
        			
        
    - 
        			Linked list are a good way to handle such situations
        
        			
    - 
        			Linked lists use a derived data type with at least two components
        				
            					
            
        - Data
            
            					
        - Pointer to next element
            
            				
        
        			
        
        		
    
    	


<pre>module list_stuff 
type llist 
integer index ! data 
<span class="r">type(llist),pointer</span>::next ! pointer to the 
! next element 
end type llist 
end module
</pre>

- - -

##[]()Linked list usage
One way to fill a linked list is to use a recursive function

<pre><span class="r">recursive</span> subroutine insert (item, <span class="r">root</span>) 
use list_stuff 
implicit none 
type(llist), pointer :: root 
integer item 
if <span class="r">(.not. associated(root))</span> then 
allocate(root) 
nullify(root%next) 
root%index = item 
else 
call <span class="r">insert</span>(item,<span class="r">root%next</span>) 
endif 
end subroutine 
</pre>
  

- - -

##[]()Our map representation


	

- An array of the derived data type states
    
    		
        			
        
    - 
        			State is name of a state
        
        
        			
    - 
        			Linked list containing boarders
        
        		
    
    	


<pre>    type states 
        character(len=2)name 
        type(llist),pointer:: list 
    end type states 
</pre>

- 
    Notes:
        
    - 
        We have an array of linked lists
        
            
        - 
            This data structure is often used to represent sparse arrays
            
            
        - 
            We could have a linked list of linked lists
            
        
        
    - 
        State name is not really required
        
    


- - -


## Non advancing and character I/O


- 
    Motivation
    
        
    - 
        We read the states using the two character identification
        
        
    - 
        One line per state and do not know how many boarder states per line
        
    

- 
    Note: Our list of states is presorted

<pre>character(len=2) a ! we have a character variable of length 2 
read(12,*)nstates ! read the number of states 
<span class="r">allocate(map(nstates)) ! and allocate our map </span>
do i=1,nstates 
    read(12,"(a2)",<span class="r">advance="no"</span>)map(i)%name <span class="r">! read the name </span>
    !write(*,*)"state:",map(i)%name 
    nullify(map(i)%list) ! "zero out" our list 
    do 
        read(12,"(1x,a2)",<span class="r">advance="no"</span>)a<span class="r"> ! read list of states 
        ! without going to the 
        ! next line </span>
        if(<span class="r">lge(a,"xx") .and. lle(a,"xx")</span>)then ! if state == xx 
        <span class="r">backspace(12) ! go to the next line 
        read(12,"(1x,a2)",end=1)a ! go to the next line </span>
        exit 
        endif 
        1 continue 
        if(llt(a,map(i)%name))then <span class="r">! we only add a state to 
        ! our list if its name 
        ! is before ours thus we 
        ! only count boarders 1 time </span>
        ! what we want put into our linked list is an index 
        ! into our map where we find the bordering state 
        ! thus we do the search here 
        ! any ideas on a better way of doing this search? 
        found=-1 
        do j=1,i-1 
            if(lge(a,map(j)%name) .and. lle(a,map(j)%name))then 
            !write(*,*)a 
            found=j 
            exit 
            endif 
        enddo 
        if(found == -1)then 
            write(*,*)"error" 
            stop 
        endif 
        <span class="r">
        ! found the index of the boarding state insert it into our list 
        ! note we do the insert into the linked list for a particular state 
        call insert(found,map(i)%list) </span>
        endif 
    enddo 
enddo 
</pre>

  

- - -

##[]()Date and time functions


- 
    Motivation
        
    - 
        May want to know the date and time of your program
        
        
    - 
        Two functions
        
    



<pre>! all arguments are optional 
call <span class="r">date_and_time</span>(date=c_date, &amp;  ! character(len=8) ccyymmdd 
                   time=c_time, &amp;  ! character(len=10) hhmmss.sss 
                   zone=c_zone, &amp;  ! character(len=10) +/-hhmm (time zone) 
                   values=ivalues) ! integer ivalues(8) all of the above 
                   
call <span class="r">system_clock</span>(count=ic,           &amp; ! count of system clock (clicks) 
                  count_rate=icr,     &amp; ! clicks / second 
                  count_max=max_c)      ! max value for count 

</pre>
  

- - -

##[]()Internal I/O


- 
    Motivation
        
    - 
        May need to create strings on the fly
        
        
    - 
        May need to convert from strings to reals and integers
        
        
    - 
        Similar to sprintf and sscanf
        
    

- 
    How it works
    
        
    - 
        Create a string
        
        
    - 
        Do a normal write except write to the string instead of file number
        
    


- 
    Example 1: creating a date and time stamped file name



<pre>character (len=12)<span class="r">tmpstr </span>
 
write(<span class="r">tmpstr</span>,"(a12)")(c_date(5:8)<span class="r">//</span>c_time(1:4)<span class="r">//</span>".dat") <span class="r">! // does string concatination </span>
write(*,*)"name of file= ",tmpstr 
open(14,file=tmpstr) 

<span class="b">name of file= 03271114.dat</span>
</pre>

	

- Example 2: Creating a format statement at run time (array of integers and a real)


<pre><span class="r">! test_vect is an array that we do not know its length until run time </span>
nstate=9 <span class="r">! the size of the array </span>
write(<span class="r">fstr</span>,'("(",i4,"i1,1x,f10.5)")')<span class="r">nstates </span>
write(*,*)"format= ",fstr 
write(*,<span class="r">fstr)test_vect,fstr</span>

<span class="b">format= ( 9i1,1x,f10.5)</span>
</pre>

Any other ideas for writing an array when you do not know its length?

 


- 
    Example 3: Reading from a string


<pre>integer ht,minut,sec
read(<span class="r">c_time</span>,"(3i2)")hr,minut,sec
</pre>
  

- - -

##[]()Inquire function


- Motivation
    
        
    - Need to get information about I/O
        
    
    

- 
    Inquire statement has two forms
    
        
    - 
        Information about files (23 different requests can be done)
        
        
    - 
        Information about space required for binary output of a value
        
    


- Example: find the size of your real relative to the "standard" real
    
        
    - Useful for inter language programming
        
        
    - Useful for determining data types in MPI (MPI_REAL or MPI_DOUBLE_PRECISION)
        
    


<pre>inquire(<span class="r">iolength=len_real</span>)1.0 
inquire(<span class="r">iolength=len_b8</span>)1.0_b8 
write(*,*)"len_b8 ",len_b8 
write(*,*)"len_real",len_real 
iratio=len_b8/len_real 
select case (iratio) 
    case (1) 
      my_mpi_type=mpi_real 
    case(2) 
      my_mpi_type=mpi_double_precision 
    case default 
      write(*,*)"type undefined" 
      my_mpi_type=0 
end select 

<span class="b">
len_b8 2 
len_real 1 
</span>
</pre>

  

- - -

##[]()Namelist


- 
    Now part of the standard

- 
    Motivation
    
        
    - 
        A convenient method of doing I/O
        
        
    - 
        Good for cases where you have similar runs but change one or two variables
        
        
    - 
        Good for formatted output
        
    

- 
    Notes:
    
        
    - 
        A little flaky
        
        
    - 
        No options for overloading format
        
    

- 
    Example:


<pre>integer ncolor 
logical force 
<span class="b">namelist /the_input/ncolor,force </span>
ncolor=4 
force=.true. 
read(13,the_input) 
write(*,the_input) 
</pre>

On input:
<pre><span class="b">&amp;THE_INPUT NCOLOR=4,FORCE = F / </span>
</pre>


Output is
<pre><span class="b">&amp;THE_INPUT 
NCOLOR = 4, 
FORCE = F 
/ 
</span>
</pre>

  
 
- - -


## Vector valued functions
 

- 
    Motivation
        
    - 
        May want a function that returns a vector
        
    

- 
    Notes
    
        
    - 
        Again requires an interface
        
        
    - 
        Use explicit or assumed size array
        
        
    - 
        Do not return a pointer to a vector unless you really want a pointer
        
    

- 
    Example:
    
        
    - 
        Take an integer input vector which represents an integer in some base and
        add 1
        
        
    - 
        Could be used in our program to find a "brute force" solution
        
    


<pre>function add1(vector,max) result (rtn) 
  integer, dimension(:),intent(in) ::  vector 
  integer,dimension(size(vector)) :: rtn 
  integer max 
  integer len 
  logical carry 
  len=size(vector) 
  rtn=vector 
  i=0 
  carry=.true. 
  do while(carry)         ! just continue until we do not do a carry 
      i=i+1 
   rtn(i)=rtn(i)+1 
   if(rtn(i) .gt. max)then 
       if(i == len)then   ! role over set everything back to 0 
        rtn=0 
    else 
        rtn(i)=0 
       endif 
   else 
       carry=.false. 
   endif 
  enddo 
end function 
</pre>
Usage
<pre>        test_vect=0 
        do 
           test_vect=add1(test_vect,3) 
           result=fitness(test_vect) 
           if(result &lt; 1.0_b8)then 
               write(*,*)test_vect 
               stop 
           endif 
        enddo 
</pre>
  
 
- - -

 
##[]()Complete source for recent discussions


- 
    [recent.f90](source/recent.f90)

- 
    [fort.13](source/fort.13)


 
  
 
- - -

Exersize 5  Modify the program to use the random
number generator given earlier.

- - -

##[]()Some array specific intrinsic functions
 

- 
    ALL True if all values are true (LOGICAL)

- 
    ANY True if any value is true (LOGICAL)

- 
    COUNT Number of true elements in an array (LOGICAL)

- 
    <span class="r">DOT_PRODUCT Dot product of two rank one arrays</span>

- 
    <span class="r">MATMUL Matrix multiplication</span>

- 
    MAXLOC Location of a maximum value in an array

- 
    MAXVAL Maximum value in an array

- 
    MINLOC Location of a minimum value in an array

- 
    MINVAL Minimum value in an array

- 
    PACK Pack an array into an array of rank one

- 
    PRODUCT Product of array elements

- 
    RESHAPE  Reshape an array

- 
    SPREAD Replicates array by adding a dimension

- 
    SUM Sum of array elements

- 
    TRANSPOSE Transpose an array of rank two

- 
    UNPACK Unpack an array of rank one into an array under a mask


 
  
 

- 
    Examples


<pre>program matrix 
    real w(10),x(10),mat(10,10) 
    call random_number(w) 
    call random_number(mat) 
    x=<span class="r">matmul</span>(w,mat)   <span class="r">! regular matrix multiply  USE IT </span>
    write(*,'("dot(x,x)=",f10.5)'),<span class="r">dot_product(x,x) </span>
end program  

program allit 
     character(len=10):: f1="(3l1)" 
     character(len=10):: f2="(3i2)" 
     integer b(2,3),c(2,3),one_d(6) 
     logical l(2,3) 
     one_d=(/ 1,3,5 , 2,4,6 /) 
     b=transpose(reshape((/ 1,3,5 , 2,4,6 /),shape=(/3,2/))) 
     C=transpose(reshape((/ 0,3,5 , 7,4,8 /),shape=(/3,2/))) 
     l=(b.ne.c) 
     write(*,f2)((b(i,j),j=1,3),i=1,2) 
     write(*,*) 
     write(*,f2)((c(i,j),j=1,3),i=1,2) 
     write(*,*) 
     write(*,f1)((l(i,j),j=1,3),i=1,2) 
     write(*,*) 
     write(*,f1)all ( b .ne. C ) !is .false. 
     write(*,f1)all ( b .ne. C, DIM=1) !is [.true., .false., .false.] 
     write(*,f1)all ( b .ne. C, DIM=2) !is [.false., .false.] 
end 
</pre>
 
- 
    The output is:

<pre><span class="b">
 1 3 5 
 2 4 6 

 0 3 5 
 7 4 8 

 TFF 
 TFT 

 F 
 TFF 
 FF 
 </span>
 </pre>
- - -


##[]()The rest of our GA



- 
    Includes

- 
    Reproduction

- 
    Mutation

- 
    Nothing new in either of these files

- 
     [Source
    and makefile](source/listing.html)





- - -


##[]()Compiler Information

### gfortran

* .f, .for, .ftn .f77
	* fixed-format Fortran source; compile
* .f90, .f95
	* free-format Fortran source; compile

* -fbacktrace
	*          Add debug information for runtime traceback

* -ffree-form -ffixed-form
	* source form

* -O0, -O1, -O2, -O3
	* optimization level

* .fpp, .FPP,  .F, .FOR, .FTN, .F90, .F95, .F03 or .F08
	* Fortran source file with preprocessor directives

* -fopenmp
	* turn on OpenMP

### Intel
* .f, .for, .ftn
	* fixed-format Fortran source; compile
* .f90, .f95
	* free-format Fortran source; compile
* -O0, -O1, -O2, -O3, -O4
	* optimization level
* .fpp, .F, .FOR, .FTN, .FPP, .F90
	* Fortran source file with preprocessor directives       
* -g 
	* compile for debug             		
* -traceback -notraceback (default)
	* Add debug information for runtime traceback
* -nofree, -free
	* Source is fixed or free format
* -fopenmp
	* turn on OpenMP


### Portland Group (x86)
*  .f, .for, .ftn
	*   fixed-format Fortran source; compile

*   .f90, .f95, .f03
	*   free-format Fortran source; compile
*    .cuf
	*    free-format CUDA Fortran source; compile

*   .CUF
	*   free-format CUDA Fortran source; preprocess, compile
       
*   -O0, -O1, -O2, -O3, -O4
	*   optimization level
       
*   -g 
	*   compile for debug             
		
* 	 -traceback (default) -notraceback
	*          Add debug information for runtime traceback

*   -Mfixed, -Mfree
	*   Source is fixed or free format
*   -qmp
	*   turn on OpenMP

### IBM xlf

* xlf, xlf_r, f77, fort77
	* Compile FORTRAN 77 source files.  _r = thread safe

* xlf90, xlf90_r, f90
	* Compile Fortran 90 source files.  _r = thread safe

* xlf95, xlf95_r, f95
	* Compile Fortran 95 source files.  _r = thread safe

* xlf2003, xlf2003_r,f2003         
	* Compile Fortran 2003 source files. _r = thread safe

* xlf2008, xlf2008_r, f2008          
	* Compile Fortran 2008 source files.

* .f, .f77, .f90, .f95, .f03, .f08      
	* Fortran source file

* .F, .F77, .F90, .F95,  .F03, .F08      
	* Fortran source file with preprocessor directives

* -qtbtable=full
	* Add debug information for runtime traceback

* -qsmp=omp
	* turn on OpenMP

* -O0, -O1, -O2, -O3, -O4, O5
	* optimization level
* -g , g0, g1,...g9
	* compile for debug             



- - -

##[]()Fortran 95


- 
    New Features
        
    - 
        The statement <span class="r">FORALL</span> as an alternative to the DO-statement
        
        
    - 
        Partial nesting of FORALL and WHERE statements
        
        
    - 
        Masked ELSEWHERE
        
        
    - 
        Pure procedures
        
        
    - 
        Elemental procedures
        
        
    - 
        Pure procedures in specification expressions
        
        
    - 
        Revised MINLOC and MAXLOC
        
        
    - 
        Extensions to CEILING and FLOOR with the KIND keyword argument
        
        
    - 
        Pointer initialization
        
        
    - 
        Default initialization of derived type objects
        
        
    - 
        Increased compatibility with IEEE arithmetic
        
        
    - 
        A CPU_TIME intrinsic subroutine
        
        
    - 
        A function NULL to nullify a pointer
        
        
    - 
        <span class="r">Automatic deallocation of allocatable arrays at exit of scoping unit</span>
        
        
    - 
        Comments in NAMELIST at input
        
        
    - 
        Minimal field at input
        
        
    - 
        Complete version of END INTERFACE
        
    

- 
    Deleted Features
        
        
    - 
        real and double precision DO loop index variables
        
        
    - 
        branching to END IF from an outer block
        
        
    - 
        PAUSE statements
        
        
    - 
        ASSIGN statements and assigned GO TO statements and the use of an assigned
        integer as a FORMAT specification
        
        
    - 
        Hollerith editing in FORMAT
        
        
        
    - 
         See [http://www.nsc.liu.se/~boein/f77to90/f95.html#17.5](http://www.nsc.liu.se/~boein/f77to90/f95.html#17.5)
        
    



- - -

##[]()Summary



- Fortran 90 has features to:
    
    
    
        
        	
        
    - Enhance performance
        
        
        
        	
    - Enhance portability
        
        
        
        	
    - Enhance reliability
        
        
        
        	
    - Enhance maintainability
        
    
    
    
    

- Fortran 90 has new language elements
    
        
        
        
        	
        
    - Source form
        
        
        
        	
    - Derived data types
        
        
        
        	
    - Dynamic memory allocation functions
        
        
        
        	
    - Kind facility for portability and easy modification
        
        
        
        	
    - Many new intrinsic function
        
        
        
        	
    - Array assignments
        
    
    

- Examples
    
    
    
        
        	
        
    - Help show how things work
        
        
        
        	
    - Reference for future use
        
    



 
 

- - -

## References

	

- [French Translation provided by Mary Orban](http://www.pkwteile.ch/science/avancee-fortran-90/)

	

- [Belorussian translation](http://webhostingrating.com/libs/pashyrany-fortran-90-be) provided by [webhostingrating.com](http://webhostingrating.com/) 

	

- [http://www.fortran.com/fortran/](http://www.fortran.com/fortran/) Pointer to everything Fortran

	

- [http://www.dmoz.org/Computers/Programming/Languages/Fortran/FAQs,_Help,_and_Tutorials/Fortran_90_and_95/](http://www.dmoz.org/Computers/Programming/Languages/Fortran/FAQs,_Help,_and_Tutorials/Fortran_90_and_95/) Cray's Manual

	

- [http://www.nova.edu/ocean/psplot.html](http://www.nova.edu/ocean/psplot.html) Postscript plotting library

	

- [http://meteora.ucsd.edu/~pierce/fxdr_home_page.html](http://meteora.ucsd.edu/~pierce/fxdr_home_page.html) Subroutines to do unformatted I/O across platforms, provided by David Pierce at UCSD

	

- [http://www.nsc.liu.se/~boein/f77to90/a5.html](http://www.nsc.liu.se/~boein/f77to90/a5.html) A good reference for intrinsic functions

	

- [A quick Summary](summary.shtml)

	

- [ftp://ftp.nag.co.uk/sc22wg5/n1551-n1600/n1579.pdf](ftp://ftp.nag.co.uk/sc22wg5/n1551-n1600/n1579.pdf)New Features of Fortran 2003

	

- [http://www.fortran.com/fortran_storenew/Html/Info/books/key10.pdf](http://www.fortran.com/fortran_storenew/Html/Info/books/key10.pdf)Key Features of Fortran 90

	

- [ftp://ftp.nag.co.uk/sc22wg5/n1701-n1750/n1729.pdf](ftp://ftp.nag.co.uk/sc22wg5/n1701-n1750/n1729.pdf)New Features of Fortran 2008

	
	

- [http://www.nsc.liu.se/~boein/f77to90/](http://www.nsc.liu.se/~boein/f77to90/) Fortran 90 for the Fortran 77 Programmer

	

- <b>[Fortran 90 Handbook Complete ANSI/ISO Reference</b>. Jeanne Adams, Walt Brainerd, Jeanne Martin, Brian Smith, Jerrold Wagener

	

- <b>[Fortran 90 Programming</b>. T. Ellis, Ivor Philips, Thomas Lahey



	

- [FFT stuff](../mkl/)

	

- [Fortran 95 and beyond](../95/)
- - -




